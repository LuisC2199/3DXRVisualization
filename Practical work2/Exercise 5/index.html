
<!-- Licensed under a BSD license. See license.html for license -->
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=yes"
    />
    <title>Exercise 5 â€“ Surface lighting</title>
    <style>
      html,
      body {
        width: 50%;
        height: 50%;
        margin: 0;
      }

      #c {
        width: 50%;
        height: 50%;
        display: block;
      }
    </style>
  </head>
  <body>
  <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.172.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.172.0/examples/jsm/"
      }
    }
  </script>
    
    <script type="module">
        import * as THREE from 'three';
        import Stats from 'three/addons/libs/stats.module.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import GUI from 'https://cdn.jsdelivr.net/npm/lil-gui@0.20/+esm';
        import { RectAreaLightHelper } from 'three/addons/helpers/RectAreaLightHelper.js';
        import { RectAreaLightUniformsLib } from 'three/addons/lights/RectAreaLightUniformsLib.js';

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Texture Loader
        const textureLoader = new THREE.TextureLoader();

        // Walls (Cornell Box)
        const createWall = (w, h, d, color, x, y, z, rx = 0, ry = 0, rz = 0) => {
            const geometry = new THREE.BoxGeometry(w, h, d);
            const material = new THREE.MeshLambertMaterial({ color:color });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, y, z);
            mesh.rotation.set(rx, ry, rz);
            scene.add(mesh);
            return mesh;
        };

        // Floor, Ceiling, and Walls
        createWall(12.5, 12.5, 0.1, 0xffffff, 0, 0, -6.25); // Back Wall
        createWall(12.5, 12.5, 0.1, 0xff0000, -6.25, 0, 0, 0, Math.PI / 2, 0); // Left Wall (Red)
        createWall(12.5, 12.5, 0.1, 0x00ff00, 6.25, 0, 0, 0, Math.PI / 2, 0); // Right Wall (Green)
        createWall(12.5, 0.1, 12.5, 0x9f9f9f, 0, -6.25, 0); // Floor
        createWall(12.5, 0.1, 12.5, 0xffffff, 0, 6.25, 0); // Ceiling

        // Table in the middle
        const createTable = (x, y, z, rotationY = 0) => {
            const tableTop = new THREE.BoxGeometry(2, 0.2, 4);
            const tableLeg = new THREE.BoxGeometry(0.2, 2.5, 0.2);
            const material = new THREE.MeshLambertMaterial({ color: 0xf0f0f0 });

            const top = new THREE.Mesh(tableTop, material);
            top.position.set(x, y + 0.6, z);
            top.rotation.y = rotationY;
            scene.add(top);

            const legOffsets = [
                [-0.9, -0.7, -1.6],
                [0.9, -0.7, -1.6],
                [-0.9, -0.7, 1.6],
                [0.9, -0.7, 1.6]
            ];

            legOffsets.forEach(offset => {
                const leg = new THREE.Mesh(tableLeg, material);
                const rotatedX = offset[0] * Math.cos(rotationY) - offset[2] * Math.sin(rotationY);
                const rotatedZ = offset[0] * Math.sin(rotationY) + offset[2] * Math.cos(rotationY);
                leg.position.set(x + rotatedX, y + offset[1], z + rotatedZ);
                scene.add(leg);
            });
        };

        createTable(-3, -4.25, 3);
        createTable(3, -4.25, 3);
        createTable(-3, -4.25, -1);
        createTable(3, -4.25, -1);
        createTable(0, -4.25, -2, Math.PI / 2);

        // Light Sources
        {
          const light = new THREE.PointLight(0xffffff, 20, 200);
          light.position.set(0, 4, 0);
          scene.add(light);

          // Ambient light
          const ambientLight = new THREE.AmbientLight(0xFFFFFF,0.6);
          scene.add(ambientLight);
        }

        // Rectangular lights
        {
          RectAreaLightUniformsLib.init();

          const rectLight1 = new THREE.RectAreaLight( 0xffffff, 5, 12.5, 12.5 );
          rectLight1.position.set( 0, 0, -6.25 );
          rectLight1.rotation.y = Math.PI;
          scene.add( rectLight1 );

          const rectLight2 = new THREE.RectAreaLight( 0xff0000, 10, 12.5, 12.5 );
          rectLight2.position.set( -6.25, 0, 0 );
          rectLight2.rotation.y = -Math.PI/2;
          scene.add( rectLight2 );

          const rectLight3 = new THREE.RectAreaLight( 0x00ff00, 1, 12.5, 12.5 );
          rectLight3.position.set( 6.25, 0, 0 );
          rectLight3.rotation.y = Math.PI/2;
          scene.add( rectLight3 );

          scene.add( new RectAreaLightHelper( rectLight1 ) );
          scene.add( new RectAreaLightHelper( rectLight2 ) );
          scene.add( new RectAreaLightHelper( rectLight3 ) );
        }

        // Camera Positioning
        camera.position.set(0, 0, 22);
        const controls = new OrbitControls(camera, renderer.domElement);

        // Lambertian Cone
        const emissiveMap = textureLoader.load('emissive.jpg');
        const coneGeometry = new THREE.ConeGeometry( 1, 3, 16 );
        const coneMaterial = new THREE.MeshLambertMaterial({ color: 0xFD7014 });
        const cone = new THREE.Mesh(coneGeometry, coneMaterial);
        cone.position.set(-3, -2, -2);
        scene.add(cone);

        // Phong Cylinder
        const specularMap = textureLoader.load('specular.jpg');
        const cylinderGeometry = new THREE.CylinderGeometry( 1, 1, 4, 16 );
        const cylinderMaterial = new THREE.MeshPhongMaterial({ color: 0x9A2C80 });
        const cylinder = new THREE.Mesh(cylinderGeometry, cylinderMaterial);
        cylinder.position.set(3, -2, -2);
        scene.add(cylinder);

        // Physical Sphere
        const clearcoatMap = textureLoader.load('clearcoat.jpg');
        const sphereGeometry = new THREE.SphereGeometry( 1, 16, 16 );
        const sphereMaterial = new THREE.MeshPhysicalMaterial({ color: 0x23EAE6 });
        const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
        sphere.position.set(0, -5.25, 2);
        scene.add(sphere);

        // GUI Setup
        const gui = new GUI();

        // Shared Folder
        const materialSettings = {
            transparent: false,
            opacity: 1.0,
        };
        const materialFolder = gui.addFolder('Shared Properties');
        materialFolder.add(materialSettings, 'transparent').onChange(value => {
            coneMaterial.transparent = value;
            cylinderMaterial.transparent = value;
            sphereMaterial.transparent = value;
        });
        materialFolder.add(materialSettings, 'opacity', 0, 1).onChange(value => {
            coneMaterial.opacity = value;
            cylinderMaterial.opacity = value;
            sphereMaterial.opacity = value;
        });

        // Lambertian Cone GUI
        const coneFolder = gui.addFolder('Lambertian Cone');
        coneFolder.addColor({ color: "#FD7014" }, 'color').onChange(value => {
            coneMaterial.color.set(value);
        });
        coneFolder.open();

        // Phong Cylinder GUI
        const cylinderFolder = gui.addFolder('Phong Cylinder');
        cylinderFolder.addColor({ color: "#9A2C80" }, 'color').onChange(value => {
            cylinderMaterial.color.set(value);
        });
        cylinderFolder.add(cylinderMaterial, 'shininess', 0, 100);
        cylinderFolder.open();

        // Physical Sphere GUI
        const sphereFolder = gui.addFolder('Physical Sphere');
        sphereFolder.addColor({ color: "#23EAE6" }, 'color').onChange(value => {
            sphereMaterial.color.set(value);
        });
        sphereFolder.add(sphereMaterial, 'roughness', 0, 1);
        sphereFolder.add(sphereMaterial, 'metalness', 0, 1);
        sphereFolder.add(sphereMaterial, 'reflectivity', 0, 1);
        sphereFolder.open();



        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        animate();
    </script>
    </body>
</html>
